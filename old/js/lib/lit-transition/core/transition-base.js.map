{"version":3,"file":"transition-base.js","sourceRoot":"","sources":["../../src/core/transition-base.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  NodePart,\n  TemplateResult,\n  html\n} from 'lit-html';\nimport {\n  marked,\n  pageVisible\n} from './utils.js'\n\nconst setup = new WeakMap();\n\n// generates a directive\nexport function transitionBase(flow:any) {\n  // generated directive\n  return function _transition(tr:TemplateResult|any, transition : any) {\n    return async (container:NodePart) => {\n      if (!(container instanceof NodePart)) {\n        throw new Error('The `transition` directive can only be used on nodes');\n      }\n\n      // skip empty templates\n      if(!tr) {\n        tr = html`<div></div>`;\n      }\n\n      if(typeof tr === 'string' || typeof tr === 'number') {\n        tr = html`<div style=\"display: inline-block\">${tr}</div>`;\n      }\n\n      // see if template was marked\n      // the name is used to decide if consider\n      // an animation to have happened\n      const name = marked(tr);\n\n      const {\n        enter,\n        leave,\n        onEnter,\n        onLeave,\n        onAfterEnter,\n        onAfterLeave,\n        mode = 'in-out'\n      } = transition;\n\n      // data is used to store some state data\n      // per container\n      let data = setup.get(container);\n      \n      // adds new template result\n      function add(e:TemplateResult) {\n        const part = new NodePart(container.options);\n        part.appendIntoPart(container);\n        part.setValue(e);\n        part.commit();\n        return part;\n      }\n  \n      // removes a template result\n      function remove(part:NodePart) {\n        const {startNode:s, endNode:e} = part;\n        try {\n          s && part.clear();\n        } catch(e) {\n          // TODO: why does this happen?\n          // out-in seems to have a bug..\n        }\n        s && s.parentNode && s.parentNode.removeChild(s);\n        e && e.parentNode && e.parentNode.removeChild(e);\n      }\n\n      // in case the page is not visible\n      // we skip all animations but still call the\n      // corresponding hooks to stay transparent\n      // in regards to app logic\n      if(!pageVisible()) {\n        data && data.last && remove(data.last);\n        // simply update dom and call hooks\n        onLeave && await onLeave();\n        onAfterLeave && await onAfterLeave();\n        onEnter && await onEnter();\n        data && (data.last = add(tr));\n        onAfterEnter && await onAfterEnter();\n        return;\n      }\n  \n      // perform enter transition\n      async function enterFlow(part:NodePart) {\n        // first mount element\n        onEnter && await onEnter();\n        enter && await flow.transition(part, enter, transition);\n        onAfterEnter && await onAfterEnter();\n      }\n  \n      // perform enter transition\n      async function leaveFlow(part:NodePart) {\n        onLeave && await onLeave();\n        leave && await flow.transition(part, leave, transition);\n        remove(part);\n        onAfterLeave && await onAfterLeave();\n      }\n  \n      // init container\n      if(!data) {\n        setup.set(container, data = {\n          children: new Map<TemplateResult, NodePart>(),\n          styles: new Map<TemplateResult, NodePart>(),\n          transition\n        });\n      }\n\n      // important in case transition has changed\n      // init flow, like to init css\n      // init must be laze\n      flow.init && flow.init({\n        transition,\n        data,\n        add,\n        remove\n      })\n\n      // same template? no animation! \n      if(data.last && !!name && name === data.name) {\n        // simply commit\n        data.last.setValue(tr);\n        data.last.commit();\n      } else {\n        // remember what template we are currently showing\n        data.name = name;\n        \n        // execute actual flow\n        if(mode === 'in-out') {\n          const last = data.last;\n          await enterFlow(data.last = add(tr));\n          last && await leaveFlow(last);\n        } else if(mode === 'out-in') {\n          // in this case we wait for leave\n          // to finish before we enter\n          const last = data.last;\n          // delete data.last;\n          last && await leaveFlow(last);\n          // trigger enter and remember part\n          // it will be pased to leaveFlow\n          // on the next transition\n          await enterFlow(data.last = add(tr));\n        } else {\n          // mode === 'both'\n          // here we don't wait so we trigger enter\n          // and leave right away\n          data.last && leaveFlow(data.last),\n          // trigger enter and remember part\n          // it will be pased to leaveFlow\n          // on the next transition\n          await enterFlow(data.last = add(tr));\n        }\n      }\n    }\n  }  \n}\n"]}